---
title: "两个SQL查询引发的mysql索引学习"
date: 2019-10-12T19:27:43+08:00
slug: mysql_index
tags: ["mysql", "index"]
categories: ["mysql"]
---

如果在业务中经常使用以下两个SQL查询：  
```sql
SELECT * FROM person WHERE `name` = 'a';
SELECT * FROM person WHERE `name` = 'a' AND age = 6;
```

则应该对`person`表怎么建索引？

## 索引

索引是帮助mysql高效获取数据的数据结构。  
常见的mysql索引有以下两种：  
* Hash索引  
* B+Tree索引  

### Hash索引

Hash索引的底层是哈希表，是一种以key-value存储数据的结构。所以数据不一定是连续的，适用于等值查询。  
有以下的缺点：  
* 无法进行范围查询  
* 无法利用索引进行排序  
* 不支持多列联合索引的最左匹配规则  
* 如果数据量大还有可能出现哈希碰撞问题  

### B+Tree索引

B+Tree是一种多路平衡查询树，他的节点是天然有序的(左节点 < 父节点, 父节点 < 右子节点)， 因此在做范围查询的时候不需要做全表扫描。  
叶子节点上存放的是key和数据， 其他节点上存放的是key  
* 如果是聚簇索引， 则存key和行完整数据  
* 如果是非聚簇索引， 则存key和索引列内容

如果使用非聚簇索引进行查询数据时， 会先使用非聚簇索引查询得到key， 然后再用key的聚簇索引取得真正的数据。  

每一个索引， 维护一个B+Tree数据结构， 因此当有数据写入时， 需要对B+Tree进行操作， 因此索引的数量会影响写入的性能。  

B+Tree树查找时， root节点是常驻内存的， 查找下一层节点时需要进行一次磁盘IO操作。

InnoDB引擎使用B+Tree来存储索引， 就是想尽量减少数据查询时磁盘IO次数。树的高度直接影响影响了查询的性能。一般树的高度在3-4层较为适宜。  
数据库分表的目的也是为了控制树的高度。

mysql可以创建联合索引， 拥有最左前缀匹配原则。  
比如： 创建了一个(key1, key2, key3)这样一个联合索引， 相当于创建(key1), (key1, key2), (key1, key2, key3)三个索引。  
因此联合索引的顺序， 识别度高的列应该放在前面。

但是有时候即使创建了索引， 使用explain进行监控查看时， 并没有生效。那是因为查询优化器在作祟。

## 查询优化器

一条SQL语句的查询， 可以有不同的执行方案， 至于最终选择哪种方案， 需要通过优化器进行选择，选择执行成本最低的方案。在一条单表查询语句真正执行之前， MySQL的查询优化器会找出执行该语句所有可能使用的方案， 对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。  
优化过程大致如下：  
1. 根据搜索条件， 找出所有可能使用的索引  
2. 计算全表扫描的代价  
3. 计算使用不同索引执行查询的代价  
4. 对比各种执行方案的代价， 找出成本最低的那一个  