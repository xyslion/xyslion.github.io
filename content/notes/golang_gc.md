---
title: "golang的gc算法理解"
date: 2019-10-08T15:57:56+08:00
categories: ["golang"]
tags: ["golang", "gc"]
---

## golang的gc算法理解

经典的gc算法有： `引用计数(reference counting)`, `标记-清除(mark-sweep)`, `复制收集(copy and collection)`.

Golang的gc算法主要基于`标记-清除(mark-sweep)`算法, 并在此基础上做了优化和改进.

以下是Golang gc算法的里程碑：

* v1.1 STW
* v1.3 Mark STW, sweep并行
* v1.5 三色标记法
* v1.8 hybird write barrier

从一开始的一进入gc， 程序就`长时间`的STW， 被人所诟病， 经过后面优化和改进， 现已经变的非常优秀了. 基本上可以做到1毫秒以下.

### 标记清除算法

该方法分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过便利访问到的对象进行标记为`被引用`；标记完成后进行清除操作，对没有标记过的内存进回收。

这种算法虽然简单，但还存在着一些问题：

* STW，stop the world； 让程序暂停， 程序出现卡顿。
* 标记需要扫描整个heap
* 清除数据会产生heap碎片

Golang是如何解决这个问题的呢？

### 三色标记算法

1. 程序开始时，所有对象都为白色。
2. gc开始时，从根出发扫描所有可达对象，标记为灰色，放入待处理队列。
3. 从队列中取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
4. 重复3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

如下图所示：  
![golang_gc](https://github.com/xyslion/blog/raw/master/static/media/golang-gc.gif)

三色标记算法大体的流程就是这样的，让我们回到刚才的问题：Golang是如何解决标记-清除(mark and sweep)算法中的卡顿(stw, stop the world)问题的呢？

### gc和用户逻辑如何并行操作？

标记-清除(mark-sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。

Golang是如何减短这个过程呢？标记-清除(mark-sweep)算法包含两部分逻辑：标记和清除。我们知道Golang的三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不触碰黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以`清除操作和用户逻辑可以并发`。

标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑是如何并发的呢？

#### 生成新对象

按照三色标记法的第一步骤来说， 新建对象会被设置为白色，但如果为白色，在执行最后一步的时候这个新建对象会不清除， 肯定会影响程序逻辑， 这样子显然不对。

Golang为了解决这个问题，引入了`写屏障`这个机制。写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其他组件感知。通俗的讲：就是在gc跑的过程中，监控对象的内存修改，并对对象重新标记(实际上也是超短暂的stw， 然后对对象进行标记)。

在上述情况中，则这时`新生成的对象，一律都标为灰色！`

#### 灰色或者黑色对象引用白色对象

一个黑色对象引用了曾经被标记为白色对象，这时候写屏障机制被触发，像gc发送信号， gc重新扫描对象并标为灰色。

因此， gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。